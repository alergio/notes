------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Basic Algorithm Scripting

    Basic Algorithm Scripting
    An algorithm is a series of step-by-step instructions that describe how to do something.

    To write an effective algorithm, it helps to break a problem down into smaller parts 
    and think carefully about how to solve each part with code.

    In this course, you'll learn the fundamentals of algorithmic thinking by writing algorithms 
    that do everything from converting temperatures to handling complex 2D arrays.


------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Convert Celsius to Fahrenheit

    The formula to convert from Celsius to Fahrenheit is the temperature in Celsius times 9/5, plus 32.

    You are given a variable celsius representing a temperature in Celsius. 
    Use the variable fahrenheit already defined and assign it 
    the Fahrenheit temperature equivalent to the given Celsius temperature. 
    Use the formula mentioned above to help convert the Celsius temperature to Fahrenheit.



Reverse a String
    
    Reverse the provided string.
    You may need to turn the string into an array before you can reverse it.
    Your result must be a string.

        const reverseString = (str) => {
            let reversedStr = ""
            for (let i = str.length - 1; i >= 0; i--) {
                reversedStr += str[i];
            }
            return reversedStr;
        }

        console.log(reverseString("hello"));        //      "olleh"



Factorialize a Number

    Return the factorial of the provided integer.

    If the integer is represented with the letter n, a factorial is the product of all positive integers less than or equal to n.

    Factorials are often represented with the shorthand notation n!

    For example: 5! = 1 * 2 * 3 * 4 * 5 = 120

    Only integers greater than or equal to zero will be supplied to the function


    empece el ejercicio con esta solucion, mala pero valida

        const factorialize = (num) => {
            let a = []
            for (let i = 1; i <= num; i++) {
                a.push(i);
            }
            let b = 1
            for (let i = 0; i < a.length-1; i++) {
                b = b * a[i+1]
            }
            return b;
        }

        console.log(factorialize(5));       //      120


    me puse a investigar y bueno.. 
    primero una solucion mas sencilla

            function factorialize(num) {
                let product = 1;
                for (let i = 2; i <= num; i++) {
                    product *= i;
                }
                return product;
            }

            factorialize(5);        //      120


    y otra que usa recursividad

        Recursive Solution

            This one starts easily since 0! = 1, so you can go ahead and simply return 1 there.

            We can use that as an if in order to break the loop we’re going to create using a recursive function. 
            It will check if the number you gave the function is 0 (which would be the end of your factorial chain). 
            Functions “end” when they return anything. 
            In fact, all functions without an explicit return statement will return undefined.

            This is also why instead of having “finished”, a function is always said to “have returned”. And now this…

        Understanding recursion

            Recursion refers to a function repeating (calling) itself. 
            In this case we are basically returning the given number (i.e. 5), 
            multiplied by the function itself but this time the value passed to the num parameter is num-1 
            (which initially translates to 4). 
            The very function is going to run inside itself interesting, eh?

        Understanding the flow

            The first returned value can be visualized better if you think about 
            those parenthesis operations you did in secondary school where you do 
            the math inside every parenthesis from inside out, bracket and square bracket 
            until you get a final result (a total). 
            This time it’s the same thing, look at the program flow:

            During the first execution of the function:

                [num = 5]
                Is 5 equal to 1 or 0? No —> Oki doki, let’s continue…

                Returns:
                (5 _(second execution: 4 _(third execution: 3 _(fourth execution: 2 _fifth execution: 1))))

                What it returns can be viewed as (5*(4*(3*(2*1)))) or just 5 * 4 * 3 * 2 * 1, and the function will return 
                the result of that operation: 120. Now, let’s check what the rest of the executions do:

                During the rest of the executions:

                Second Execution: num = 5-1 = 4 → is num 0 or 1? No
                → return the multiplication between 4 and the next result when num is now 4-1.

                Third Execution: num = 4 - 1 = 3 → is num 0 or 1? No
                → return the multiplication between 3 and the next result when num is now 3-1.

                Fourth Execution: num = 3-1 = 2 → is num 0 or 1? No
                → return the multiplication between 2 and the next result when num is now 2-1.

                Fifth Execution: num = 2-1 = 1 → is num 0 or 1? Yep
                → return 1. And this is where the recursion stops because there are no more executions.


        SOLUCION CON RECURSIVIDAD

            function factorialize(num) {
                if (num === 0) {
                    return 1;
                }
                return num * factorialize(num - 1);
            }

            factorialize(5);        //      120



Find the Longest Word in a String

    Return the length of the longest word in the provided sentence.

    Your response should be a number.

        para resolver esto tuve que investigar sobre el metodo split() (lo agregue al doc methods.txt)
        split en este caso me permitira separar un string en palabras y pushearlas a un array.

        
        solucion que cree:

            const findLongestWordLength = (str) => {
                let strArray = str.split(' ');
                let maxLength = 0;
                for (let i = 0; i < strArray.length; i++) {
                    if (strArray[i].length > maxLength){
                        maxLength = strArray[i].length;
                    }
                }
                return maxLength;
            }


        tambien se podia hacer con map y mathmax

            function findLongestWordLength(str) {
                return Math.max(...str.split(" ").map(word => word.length));
            }

                We provide Math.max with the length of each word as argument, 
                and it will simply return the highest of all.

                str.split(" ") splits the string into an array, taking spaces as separators. 
                It returns this array: 
                [“The”,"quick,“brown”,“fox”,“jumped”,“over”,“the”,“lazy”,“dog”].

                Then, we will make another array, 
                made from the lengths of each element of the str.split(" ") array with map().

                str.split(" ").map(word => word.length)     //  map itera con cada elemento de un array 
                                                                y lo devuelve en otro array
                returns [3, 5, 5, 3, 6, 4, 3, 4, 3]

                Finally, we pass the array as argument for the Math.max function with the spread operator ...
                para desglosarlo ya que Math.max trabaja con numeros, no con arrays.


        tambien se podia hacer con .reduce() pero no lo he investigado



Return Largest Numbers in Arrays

    Return an array consisting of the largest number from each provided sub-array. 
    For simplicity, the provided array will contain exactly 4 sub-arrays.

    Remember, you can iterate through an array with a simple for loop, 
    and access each member with array syntax arr[i].

        the solution I found

            function largestOfFour(arr) {
                let largestArr = [];
                for (let i = 0; i < arr.length; i++) {
                    largestArr.push(Math.max(...arr[i]))
                }
                return largestArr;
            }

            console.log(largestOfFour([[4, 5, 1, 3], [13, 27, 18, 26], [32, 35, 37, 39], [1000, 1001, 857, 1]]));

                //  [ 5, 27, 39, 1001 ]

            
        this would have been better:

            const largestOfFour = (arr) => arr.map(item => Math.max(...item));

        the map method iterate with each of the arrays inside the arr and 
        it was saving the highest in a new array that he retorned when he finished.



Confirm the Ending

    Check if a string (first argument, str) 
    ends with the given target string (second argument, target).

    This challenge can be solved with the .endsWith() method, 
    which was introduced in ES2015. 
    But for the purpose of this challenge, 
    we would like you to use one of the JavaScript substring methods instead.

        the solution:

            const confirmEnding = (str, target) => {
                let a = new RegExp(target + '$', 'i')
                return a.test(str);
            }

            console.log(confirmEnding("Bastian", "n"));     //      true


        and another solution

            function confirmEnding(str, target) {
                return str.slice(str.length - target.length) === target;
            }

        OR

            function confirmEnding(str, target) {
               return str.slice(-target.length) === target
            }


                First we use the slice method copy the string.
                In order to get the last characters in str equivalent to the target's length we use the slice method.
                The first parameter inside the slice method is the starting index 
                and the second parameter would be the ending index.
                For example str.slice(10, 17) would return give me.
                In this case we only include one parameter 
                which it will copy everything from the starting index.
                We substract the length of str and the length of target, 
                that way, we shall get the last remaining characters equivalent to the target's length.
                Finally we compare the return result of slice to target and check if they have the same characters.

                (for second case):
                    If a negative number is provided as the first parameter to slice() , 
                    the offset is taken backwards from the end of the string.


