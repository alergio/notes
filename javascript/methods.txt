operators



typeof

    The typeof operator returns a string indicating the type of the operand's value.

    console.log(typeof 42);
    // expected output: "number"

    console.log(typeof 'blubber');
    // expected output: "string"

    console.log(typeof true);
    // expected output: "boolean"

    console.log(typeof undeclaredVariable);
    // expected output: "undefined"



The Boolean Object/FUNCTION

    There is also a native JavaScript object that wraps around a value. 
    The value passed as the first parameter is converted to a boolean value, if necessary. 
    If a value is omitted, 0, -0, null, false, NaN, undefined, or the empty string (""), the object has an initial value of false. 
    All other values, including any object or the string “false”, create an object with an initial value of true.

    Do not confuse the primitive Boolean values true and false with the true and false values of the Boolean object.

        example using filter method

            function bouncer(arr) {
                return arr.filter(Boolean);
            }

        filter receive each arr item and applies the Boolean function to it to check if it is true or false
        then return the filtered array.
            



--------------------------------------------------------------------

methods



.split()

    https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/split

    The split() method takes a pattern and divides a String into an ordered list of substrings 
    by searching for the pattern, puts these substrings into an array, and returns the array.

        const str = 'The quick brown fox jumps over the lazy dog.';

        const words = str.split(' ');
        console.log(words[3]);
        // expected output: "fox"

        // words value is 
            [
                'The',   'quick',
                'brown', 'fox',
                'jumps', 'over',
                'the',   'lazy',
                'dog.'
            ]


        const chars = str.split('');
        console.log(chars[8]);
        // expected output: "k"

        // chars value is
            [
                'T', 'h', 'e', ' ', 'q', 'u', 'i',
                'c', 'k', ' ', 'b', 'r', 'o', 'w',
                'n', ' ', 'f', 'o', 'x', ' ', 'j',
                'u', 'm', 'p', 's', ' ', 'o', 'v',
                'e', 'r', ' ', 't', 'h', 'e', ' ',
                'l', 'a', 'z', 'y', ' ', 'd', 'o',
                'g', '.'
            ]


        const strCopy = str.split();
        console.log(strCopy);
        // expected output: ["The quick brown fox jumps over the lazy dog."]


        split can receive two paremeters, but for now I only care the first one.
        that parameter tells the split when to stop, pushing to in the array and to be continue
        if that parameter is empty, the split will generate an array with the entire string
        if that parameter is a empty string, the split will generate an array with each of the characters
        if that parameter is a space (' '), split will generate an array and push in 
        the content every time he finds a space 



Math.max()

    wait for numbers separated by commas and returns the largest number
    or NaN if he can't solve it



Map()

    is an excelent resource for iterating arrays, better than foor loop.

    The map() method is used for creating a new array from an existing one, 
    applying a function to each one of the elements of the first array.
    se le aplica la funcion asignada a cada uno de los elementos dentro del array.

            const numbers = [1, 2, 3, 4];
            const doubled = numbers.map(item => item * 2);
            console.log(doubled); // [2, 4, 6, 8]
        
    and this is an example using the function Math.max and spread operator (...) to split an array
    because Math.max only works with numbers and not with arrays.
        note: this function is made to receive an array of arrays
        that is why he need split the item, because item is an array inside another array 
        (arr), the one being mapped.

            const largestOfFour = (arr) => arr.map(item => Math.max(...item));
        
        remember that the .map() method always returns an array that contains each of
        operators that it resolved in each iteration.
        so

            largestOfFour([[1, 2, 3], [4, 5, 6]]);  //  [3, 6]



method .toLowerCase() 

    will return the value of the string converted to lower case. The original string is not changed.

    string.toLowerCase()

    Examples
    var shout = "I AM SHOUTING VERY LOUDLY"
    var whisper = shout.toLowerCase()
    
    console.log(shout) // will return "I AM SHOUTING VERY LOUDLY"
    console.log(whisper) // will return "i am shouting very loudly"

    same for .toUpperCase()
        


The replace() 
    
    method returns a new string with some or all matches of a pattern replaced by a replacement. 
    The pattern can be a string or a RegExp, 
    and the replacement can be a string or a function to be called for each match.

    
    str.replace(regexp|substr, newSubStr|function[, flags])

        var str = 'Twas the night before Xmas...';
        var newstr = str.replace(/xmas/i, 'Christmas');
        console.log(newstr);  // Twas the night before Christmas...



filter()

    Array.prototype.filter
    The filter method takes an array as an input. 
    It takes each element in the array and it applies a conditional statement against it. 
    If this conditional returns true, the element gets “pushed” to the output array.

    Once each element in the input array is “filtered” as such, 
    it outputs a new array containing each element that returned true.

    In this example below, there is an array that has multiple objects within it. 
    Normally, to iterate through this array, you might use a for loop.

    In this case, we want to get all the students whose grades are greater than or equal to 90.

            var students = [
                { name: 'Quincy', grade: 96 },
                { name: 'Jason', grade: 84 },
                { name: 'Alexis', grade: 100 },
                { name: 'Sam', grade: 65 },
                { name: 'Katie', grade: 90 }
            ];

            var studentsGrades = []
            for (var i = 0; i < students.length; i++) {
                if (students[i].grade >= 90) {
                    studentsGrades.push(students[i])
                }
            }

            return studentsGrades; // [ { name: 'Quincy', grade: 96 }, { name: 'Alexis', grade: 100 }, { name: 'Katie', grade: 90 } ]


    This for loop works, but it is pretty lengthy. 
    It can also become tedious to write for loops over and over again for many arrays that you need to iterate through.
    This is a great use case for filter!

    Here is the same example using filter:

                var students = [
                    { name: 'Quincy', grade: 96 },
                    { name: 'Jason', grade: 84 },
                    { name: 'Alexis', grade: 100 },
                    { name: 'Sam', grade: 65 },
                    { name: 'Katie', grade: 90 }
                ];

                var studentGrades = students.filter(function (student) {
                    return student.grade >= 90;
                });

                return studentGrades; // [ { name: 'Quincy', grade: 96 }, { name: 'Alexis', grade: 100 }, { name: 'Katie', grade: 90 } ]


    The filter method is much faster to write and cleaner to read while still accomplishing the same thing. 
    Using ES6 syntax we can even replicate the 6-line for-loop with filter:

                var students = [
                    { name: 'Quincy', grade: 96 },
                    { name: 'Jason', grade: 84 },
                    { name: 'Alexis', grade: 100 },
                    { name: 'Sam', grade: 65 },
                    { name: 'Katie', grade: 90 }
                ];

                var studentGrades = students.filter(student => student.grade >= 90);
                return studentGrades; 

                    // [ { name: 'Quincy', grade: 96 }, { name: 'Alexis', grade: 100 }, { name: 'Katie', grade: 90 } ]


    Filter is very useful and a great choice over for loops to filter arrays against conditional statements.



sort()

    este metodo se puede usar sin parametros pero la forma que utiliza para ordenar los elementos de un array
    no es util si no son numeros ya que compara solo el primer digito.

    hay que usarla con parametros para comparar efectivamente numeros de varios digitos

    allow receive a CompareFunction
    Specifies a function that defines the sort order. 

    If compareFn is supplied, all non-undefined array elements 
    are sorted according to the return value of the compare function 
    (all undefined elements are sorted to the end of the array, with no call to compareFn).

    compareFn(a, b)     return value	    sort order
                            > 0	                sort a after b
                            < 0	                sort a before b
                            === 0	            keep original order of a and b

        The following function will sort the array in ascending order

            function compareNumbers(a, b) {
                return a - b;
            }

            const numberArray = [40, 1, 5, 200];
            numberArray.sort(compareNumbers); // [1, 5, 40, 200]

            const points = [40, 100, 1, 5, 25, 10];
            // Sort the numbers in ascending order
            points.sort(function(a, b){return a-b});

            const points = [40, 100, 1, 5, 25, 10];
            // Sort the numbers in descending order:
            points.sort(function(a, b){return b-a});


            function compare(a, b){
                if (a < b){return -1;}
                if (a > b){return 1;}
                if (a === b){return 0;}
            }

            var myArray = [1, 2, 23, 13];
            console.log(myArray.sort(compare));   // [ 1, 2, 13, 23 ]


            Solamente le decís al sort cómo saber cuándo un valor va antes o después de otro
            sobre esos 2 parametros que recibe: Dos ítems cualquiera del array, 
            el sort la va a llamar a la función reiteradas veces, comparando entre sí todos los elementos del array.

            los valores que devuelve, negativo, 0 o positivo son para decirle al sort donde ordenar.



concat()

    Array.prototype.concat()
    The concat() method is used to merge two or more arrays. 
    This method does not change the existing arrays, but instead returns a new array.
                
         const array1 = ['a', 'b', 'c'];
        const array2 = ['d', 'e', 'f'];
        const array3 = array1.concat(array2);

        console.log(array3);
        // expected output: Array ["a", "b", "c", "d", "e", "f"]

        Concatenating three arrays
            
            const num1 = [1, 2, 3];
            const num2 = [4, 5, 6];
            const num3 = [7, 8, 9];

            const numbers = num1.concat(num2, num3);

            console.log(numbers);
            // results in [1, 2, 3, 4, 5, 6, 7, 8, 9]

        Concatenating values to an array
            
            const letters = ["a", "b", "c"];

            const alphaNumeric = letters.concat(1, [2, 3]);

            console.log(alphaNumeric);
            // results in ['a', 'b', 'c', 1, 2, 3]

        Concatenating nested arrays
            
            const num1 = [[1]];
            const num2 = [2, [3]];

            const numbers = num1.concat(num2);

            console.log(numbers);
            // results in [[1], 2, [3]]
    


every()

    The every() method tests whether all elements in the array pass the test implemented by the provided function.

        arr.every(callback[, thisArg])

    Parameters

        callback: Function to test for each element, taking three arguments:
        currentValue: (required)The current element being processed in the array.
        index: (optional)The index of the current element being processed in the array.
        array: (optional)The array every was called upon.
        thisArg: Optional. Value to use as this when executing callback.

    The every method calls the callback function one time for each array element, 
    in ascending index order, until the callback function returns false. 
    If an element that causes callback to return false is found, the every method immediately returns false . 
    Otherwise, the every method returns true .

    In addition to array objects, the every method can be used by any object 
    that has a length property and that has numerically indexed property names. 
    every does not mutate the array on which it is called.

          function isBigEnough(element, index, array) {
            return element >= 10;
        }
        [12, 5, 8, 130, 44].every(isBigEnough);   // false
        [12, 54, 18, 130, 44].every(isBigEnough); // true


        also work without index and array parameters.












